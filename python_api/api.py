import sqlite3
import json
import time
import aiosqlite
from TikTokApi import TikTokApi
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from fastapi.responses import JSONResponse, HTMLResponse, FileResponse
from contextlib import asynccontextmanager
import asyncio
import os
import logging
import base64
import httpx
import tempfile
import cv2
import uuid
from yt_dlp import YoutubeDL
from shazamio import Shazam
import uvicorn

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(funcName)s] - %(message)s')
logger = logging.getLogger(__name__)
load_dotenv()
ms_token = os.environ.get("MS_TOKEN")
if not ms_token:
    raise ValueError("ms_token не найден в .env файле.")

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DB_FILE = os.path.join(BASE_DIR, "cache.db")
VIDEO_CACHE_DIR = os.path.join(BASE_DIR, "video_cache")
AUDIO_DIR = os.path.join(BASE_DIR, "audio_files")

for folder in [VIDEO_CACHE_DIR, AUDIO_DIR]:
    if not os.path.exists(folder):
        os.makedirs(folder)
app_state = {}

def init_db_sync():
    logger.info(f"Проверяем и инициализируем базу данных: {DB_FILE}")
    try:
        con = sqlite3.connect(DB_FILE)
        cur = con.cursor()
        cur.execute("""
            CREATE TABLE IF NOT EXISTS videos (
                video_id TEXT PRIMARY KEY,
                metadata TEXT NOT NULL,
                video_file_path TEXT NOT NULL,
                audio_file_path TEXT,
                created_at INTEGER NOT NULL
            )
        """)
        con.commit()
        con.close()
        logger.info("База данных успешно инициализирована.")
    except Exception as e:
        logger.error(f"КРИТИЧЕСКАЯ ОШИБКА при инициализации БД: {e}", exc_info=True)
        raise e

@asynccontextmanager
async def lifespan(app: FastAPI):
    init_db_sync()
    logger.info("Запускаем TikTok API и создаем сессию...")
    api = TikTokApi()
    await api.create_sessions(ms_tokens=[ms_token], num_sessions=1, sleep_after=3, headless=True, browser="chromium")
    app_state["api"] = api
    app_state["shazam"] = Shazam()
    app_state["lock"] = asyncio.Lock()
    logger.info(">>> Python API готов к приему запросов! <<<")
    yield
    logger.info("Закрываем сессию TikTok API...")
    if "api" in app_state and app_state["api"]:
        await app_state["api"].close_sessions()

app = FastAPI(lifespan=lifespan)

async def download_music(search_query: str) -> str | None:
    cookie_file = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.txt', encoding='utf-8')
    try:
        # --- ВАШИ YOUTUBE COOKIES, СКОПИРОВАННЫЕ ИЗ РАСШИРЕНИЯ ---
        netscape_cookies = """
# Netscape HTTP Cookie File
# http://curl.haxx.se/rfc/cookie_spec.html
# This file was generated by Cookie-Editor
#HttpOnly_.youtube.com	TRUE	/	TRUE	1789418570	VISITOR_PRIVACY_METADATA	CgJHQhIEGgAgYg%3D%3D
#HttpOnly_.youtube.com	TRUE	/	TRUE	1787762858	__Secure-YEC	CgtNQXJLUTlnVTc0SSjKt_7EBjIKCgJHQhIEGgAgYg%3D%3D
#HttpOnly_.youtube.com	TRUE	/	TRUE	1789850561	__Secure-3PSID	g.a0000QhpKEYXY_Srx5YXSEwxLbdO9iwRbryJ9RfVm_Jjw0cPS6P_L94JiZAWKD-l4sAhjtZF-wACgYKAeQSARYSFQHGX2MiG___OUfJG4WUwBz2fiV_8xoVAUF8yKr_7hC3sjaJABJ_SoS1USGr0076
.youtube.com	TRUE	/	FALSE	1786826571	SIDCC	AKEyXzUvZsJrFScP1F0WnK4cu5vHUWgIbYdjeoKF4PU_1zmrqnJ2UKn0QCZuA6nSIhi7cefkVA
#HttpOnly_.youtube.com	TRUE	/	FALSE	1755377688	YSC	R4HoWrWdWE8
.youtube.com	TRUE	/	FALSE	1789850561	SID	g.a0000QhpKEYXY_Srx5YXSEwxLbdO9iwRbryJ9RfVm_Jjw0cPS6P_bfanohItyNDjJrmSdd8WkwACgYKAc8SARYSFQHGX2MiYK2g7OeV3t4-x-LC3M_orhoVAUF8yKq1_WiS0HkItFMAS5snONbp0076
#HttpOnly_.youtube.com	TRUE	/	TRUE	1785170862	__Secure-1PSIDTS	sidts-CjIB5H03P-BUZE3gYlZYc4NPs77ru687PHJrf1SiweD4-M9kat_AqUtKfZDtzHEWGMQMuRAA
.youtube.com	TRUE	/	TRUE	1789850561	SAPISID	vkWki_pK-5GCWru7/A6RJhhF3E8EtYYI9K
#HttpOnly_.youtube.com	TRUE	/	TRUE	1786826571	__Secure-1PSIDCC	AKEyXzUdHzR8_5jDyBBC_m2W5__KmgUqtr9iXsP9lCwiuMUWEDlK_Q9eLBkdRXv_bHIXDNNNgA
#HttpOnly_.youtube.com	TRUE	/	TRUE	1789850561	SSID	A1NDcff85yot3pdGu
.youtube.com	TRUE	/	TRUE	1789850561	__Secure-1PAPISID	vkWki_pK-5GCWru7/A6RJhhF3E8EtYYI9K
#HttpOnly_.youtube.com	TRUE	/	TRUE	1789850561	__Secure-1PSID	g.a0000QhpKEYXY_Srx5YXSEwxLbdO9iwRbryJ9RfVm_Jjw0cPS6P_70O0BuQ6d8D26yebIKl9MwACgYKAbsSARYSFQHGX2Mi7D_qZmWptV7EOurPg7WmuBoVAUF8yKqdzJ20fKpkHjQu-KfYypIp0076
.youtube.com	TRUE	/	TRUE	1789850561	__Secure-3PAPISID	vkWki_pK-5GCWru7/A6RJhhF3E8EtYYI9K
#HttpOnly_.youtube.com	TRUE	/	TRUE	1786826571	__Secure-3PSIDCC	AKEyXzXA8rfCIa0VtVaKKAZKow2TSuNLLKxD1ns6b7n6ty_RhP-qr7ieU2s3bHmrW-DSPNrvtQ
#HttpOnly_.youtube.com	TRUE	/	TRUE	1785170862	__Secure-3PSIDTS	sidts-CjIB5H03P-BUZE3gYlZYc4NPs77ru687PHJrf1SiweD4-M9kat_AqUtKfZDtzHEWGMQMuRAA
.youtube.com	TRUE	/	FALSE	1789850561	APISID	9nM45AqlT2N7eU7Z/AeN1IrcLT4S4qf2fa
#HttpOnly_.youtube.com	TRUE	/	FALSE	1789850561	HSID	AS1rt45dWIHGFRpWe
#HttpOnly_.youtube.com	TRUE	/	TRUE	1788194863	LOGIN_INFO	AFmmF2swRgIhAIUnq9iCdnJW9eZXHeFEfdD0oA-frRYmFMFZpVcfPnkkAiEAheOPSmxtF85wfZToz8Afmp_vnhXza_RApLNQzQDANnY:QUQ3MjNmeGlEa0M0RFd5S1N4QndISHVCOFJ2NFdsT29EYlU2c0FqaWxpQTFVT2NkdUlkMmpTdFlOSDhKSWRWOHpOaFRGXzdiRzlmai1lTk95a2xZNm1OUm0tdVZaZVZRbFRacXI1TFJIaUtJNC1jbmhmRUk0ME1lNHZBMjdHOVhiODVVeFVlb0FMaXFGemxyZ094VzJqSEVleVFYSXVhYy1n
.youtube.com	TRUE	/	TRUE	1789850570	PREF	tz=Europe.Moscow
.youtube.com	TRUE	/	FALSE	1753634879	ST-1nu4587	csn=CttDRyNBp3r2IF1z&itct=CE8Q_FoYASITCIrzqfm-3Y4DFf78OwIdQX4FRlIHeW91dHViZZoBBQgyEPQk
        """
        
        cookie_file.write(netscape_cookies.strip())
        cookie_file.close()

        music_file_id = str(uuid.uuid4())
        audio_path = os.path.abspath(os.path.join(AUDIO_DIR, f"{music_file_id}.mp3"))
        search_string = f"ytsearch1:{search_query}"
        
        ydl_opts = {
            'format': 'bestaudio/best',
            'cookiefile': cookie_file.name,
            'outtmpl': audio_path.replace('.mp3', ''),
            'postprocessors': [{'key': 'FFmpegExtractAudio', 'preferredcodec': 'mp3', 'preferredquality': '192'}],
            'quiet': True,
            'no_warnings': True,
        }

        logger.info(f"Ищем и скачиваем музыку с YouTube (с cookies) по запросу: '{search_string}'")
        with YoutubeDL(ydl_opts) as ydl:
            ydl.download([search_string])

        if os.path.exists(audio_path):
            logger.info(f"Музыка успешно сохранена в: {audio_path}")
            return audio_path
        else:
            logger.error(f"yt-dlp завершил работу, но файл {audio_path} не найден.")
            return None
    except Exception as e:
        logger.error(f"Ошибка при поиске/скачивании музыки через yt-dlp: {e}", exc_info=True)
        return None
    finally:
        if os.path.exists(cookie_file.name):
            os.remove(cookie_file.name)

async def resolve_short_url(url: str):
    if "vt.tiktok.com" in url or "vm.tiktok.com" in url:
        try:
            async with httpx.AsyncClient(follow_redirects=True) as client:
                r = await client.head(url, timeout=15.0)
                return str(r.url).split("?")[0]
        except httpx.RequestError:
            raise HTTPException(status_code=400, detail="Не удалось обработать короткую ссылку TikTok.")
    return url

@app.get("/video_data")
async def get_video_data(original_url: str):
    async with app_state["lock"]:
        url = await resolve_short_url(original_url)
        video_id = url.split("/")[-1].split("?")[0]
        
        week_ago = int(time.time()) - 7 * 24 * 60 * 60
        async with aiosqlite.connect(DB_FILE) as db:
            async with db.execute("SELECT metadata, video_file_path FROM videos WHERE video_id = ? AND created_at >= ?", (video_id, week_ago)) as cursor:
                cached = await cursor.fetchone()
        
        if cached and os.path.exists(cached[0]):
            logger.info(f"Найдено в кэше: {video_id}")
            metadata = json.loads(cached[1])
            video_file_path = cached[0]
            return JSONResponse(content={"metadata": metadata, "videoFilePath": video_file_path})

        logger.info(f"Не найдено в кэше, загружаем: {video_id}")
        video_obj = app_state["api"].video(url=url)
        video_data = await video_obj.info(use_video_v2=True)
        
        no_watermark_url = video_data.get("video", {}).get("playAddr")
        if not no_watermark_url: raise HTTPException(status_code=404, detail="URL для скачивания не найден.")
        
        _, session = app_state["api"]._get_session()
        cookies = await app_state["api"].get_session_cookies(session)
        headers = {**session.headers, 'Referer': 'https://www.tiktok.com/'}
        async with httpx.AsyncClient() as client:
            r = await client.get(no_watermark_url, headers=headers, cookies=cookies, follow_redirects=True, timeout=60.0)
            r.raise_for_status()
            video_bytes = r.content

        video_file_path = os.path.abspath(os.path.join(VIDEO_CACHE_DIR, f"{video_id}.mp4"))
        with open(video_file_path, "wb") as f: f.write(video_bytes)
        
        cap = cv2.VideoCapture(video_file_path)
        video_details = {"resolution": f"{int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))}x{int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))}", "fps": round(cap.get(cv2.CAP_PROP_FPS)), "size_mb": f"{os.path.getsize(video_file_path) / (1024 * 1024):.2f} MB"}
        cap.release()

        shazam_result, audio_file_path, music_file_id = None, None, None
        try:
            with tempfile.NamedTemporaryFile(delete=True, suffix=".mp4") as temp_file:
                temp_file.write(video_bytes)
                recognition = await app_state["shazam"].recognize(temp_file.name)
                if recognition.get('track'):
                    shazam_result = {"artist": recognition['track'].get('subtitle', 'Неизвестен'), "title": recognition['track'].get('title', 'Неизвестно')}
                    if shazam_result["title"] != 'Неизвестно':
                        audio_file_path = await download_music(f"{shazam_result.get('artist', '')} {shazam_result.get('title', '')}")
                        if audio_file_path:
                            music_file_id = os.path.basename(audio_file_path).replace('.mp3', '')
        except Exception as e:
            logger.error(f"Ошибка Shazam: {e}")

        metadata = {
            "video_id": video_id, "author": video_data.get('author', {}), "music": video_data.get('music', {}), 
            "description": video_data.get('desc'), "statistics": video_data.get('stats', {}), 
            "region": video_data.get('locationCreated'), "video_details": video_details, 
            "shazam": shazam_result, "authorStats": video_data.get('authorStats', {}), 
            "createTime": video_data.get('createTime'), "video_duration": video_data.get('video', {}).get('duration'), 
            "isDuet": bool(video_data.get('duetInfo')), "isStitch": bool(video_data.get('stitchInfo')), 
            "shadow_ban": bool(video_data.get("warnInfo") or video_data.get("privateItem", False)), "music_file_id": music_file_id
        }
        
        async with aiosqlite.connect(DB_FILE) as db:
            await db.execute("INSERT OR REPLACE INTO videos (video_id, metadata, video_file_path, created_at) VALUES (?, ?, ?, ?)", (video_id, json.dumps(metadata), video_file_path, int(time.time())))
            await db.commit()
        logger.info(f"Сохранено в кэш: {video_id}")
            
        video_base64 = base64.b64encode(video_bytes).decode('utf-8')
        return JSONResponse(content={"metadata": metadata, "videoBase64": video_base64})

@app.get("/video_file/{video_id}")
async def get_video_file(video_id: str):
    file_path = os.path.join(VIDEO_CACHE_DIR, f"{video_id}.mp4")
    if not os.path.exists(file_path): raise HTTPException(status_code=404, detail="Видеофайл не найден.")
    return FileResponse(path=file_path, media_type='video/mp4')

@app.get("/audio/{file_id}")
async def get_audio_file(file_id: str):
    file_path = os.path.join(AUDIO_DIR, f"{file_id}.mp3")
    if not os.path.exists(file_path): raise HTTPException(status_code=404, detail="Файл не найден.")
    return FileResponse(path=file_path, media_type='audio/mpeg', filename=f"track.mp3")

@app.get("/download/{video_id}/{music_file_id}", response_class=HTMLResponse)
async def download_page_with_video(video_id: str, music_file_id: str):
    video_path = os.path.join(VIDEO_CACHE_DIR, f"{video_id}.mp4")
    music_path = os.path.join(AUDIO_DIR, f"{music_file_id}.mp3")
    if not os.path.exists(video_path) or not os.path.exists(music_path):
        return HTMLResponse(content="<h1>Ошибка 404: Файл не найден или устарел.</h1>", status_code=404)
    html_content = f"""<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Скачать трек</title><link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" /><style>:root {{ --plyr-color-main: #1778f2; }}body {{ margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: #000; color: #fff; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }}#bg-video {{ position: fixed; top: 50%; left: 50%; min-width: 100%; min-height: 100%; width: auto; height: auto; z-index: -1; transform: translateX(-50%) translateY(-50%); filter: blur(20px); opacity: 0.3; object-fit: cover; }}.container {{ z-index: 1; text-align: center; background-color: rgba(0, 0, 0, 0.5); padding: 40px; border-radius: 15px; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); }}h1 {{ margin-top: 0; font-weight: 500; }}.player-container {{ margin-bottom: 25px; }}.download-btn {{ display: inline-block; text-decoration: none; background-color: var(--plyr-color-main); color: white; padding: 12px 24px; border-radius: 8px; font-size: 16px; font-weight: bold; transition: background-color 0.3s, transform 0.2s; }}.download-btn:hover {{ background-color: #1464c7; transform: scale(1.05); }}</style></head><body><video autoplay muted loop id="bg-video"><source src="/video_file/{video_id}" type="video/mp4"></video><div class="container"><h1>Прослушать и скачать трек</h1><div class="player-container"><audio id="player" controls><source src="/audio/{music_file_id}" type="audio/mp3" /></audio></div><a href="/audio/{music_file_id}" class="download-btn" download>Скачать MP3</a></div><script src="https://cdn.plyr.io/3.7.8/plyr.js"></script><script>const player = new Plyr('#player');</script></body></html>"""
    return HTMLResponse(content=html_content)

if __name__ == "__main__":
    os.chdir(os.path.dirname(__file__))
    uvicorn.run("api:app", host="0.0.0.0", port=18361)